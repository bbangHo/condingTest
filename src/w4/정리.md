## 팁

- 질문 게시판 보면 몇% 틀려요 하는 게시글이 있을 거다
    - 몇% 틀리는지는 의미없다고 한다.
- 100% 틀리는 거는 좀 유의미 할 수도 있는데,
    - 이유는 정말 작은, 정말 기본적인 예외에서 틀렸을 가능성이 높기 때문
        - 1을 입력하고 1을 출력 해야하는 예제에서 1을 넣었는데 0을 출력하는 등

### java의  Collections.binarySearch

```
List al = new ArrayList();
al.add(1);  // 0
al.add(2);  // 1
al.add(3);  // 2
al.add(4);  // 3
al.add(4);  // 4
al.add(4);  // 5
al.add(5);  // 6
al.add(5);  // 7
al.add(6);  // 8

int index = Collections.binarySearch(al, 4);
System.out.println(index);  // 4  -> lower_bound를 찾지 못함

index = Collections.binarySearch(al, 6);
System.out.println(index);  // 8
```
- 함수로 편안하게 찾아보려 했지만 중복값이 있을 때 제대로 작동하지 못하는 모습

## lower / upper bound
- Upper Bound: **target보다 큰 첫번째 위치**(초과)를 반환.
  > [0, 1, 2, 3, 4, 5, 6]\
  > [1, 2, 4, 4, 4, 5, 6], target = 4\
  > index: 5
  ```
  public static int upperBound(int low, int high, int target) {
        while (low < high) {
            int mid = (low + high) / 2;

            if (al.get(mid) <= target)
                low = mid + 1;
            else // target > mid
                high = mid;
        }
        return high;
  }
  ```
- Lower Bound: **target보다 크거나 같은 첫번째 위치**(이상)를 반환.
  ```
  public static int lowerBound(int low, int high, int target) {
          while (low < high) {
              int mid = (low + high) / 2;
  
              if (al.get(mid) < target)
                  low = mid + 1;
              else // target <= mid
                  high = mid;
          }
          return high;
  }
  ```
  - 만약 arr[..., 4, 4, 4, ...], target = 4 인 경우 
  - mid가 4의 어떤 index에 위치하든 else조건 (target <= mid)에 걸림
  - high = mid 가 됨. 그 다음 동작에서 arr[mid] = 4 이면 같은 과정을 반복,
  - arr[mid] < 4 이면, if 문에 걸려서 left = mid + 1 을 수행
  - 결국 첫 번째 인덱스에 low과 high이 모이게 되고 while 종류 후 high 리턴
  > [0, 1, 2, 3, 4, 5, 6]\
  > [1, 2, 4, 4, 4, 5, 6], target = 4
  > 
  > [1, 2, 4, 4, 4, 5, 6]\
  > [L, _, _, M, _, _, R], target = 4
  >
  > [1, 2, 4, 4, 4, 5, 6]\
  > [L, M, _, R, _, _, _], target = 4
  >
  > [1, 2, 4, 4, 4, 5, 6]\
  > [_, _, LR, _, _, _, _], target = 4\
  > index: 2