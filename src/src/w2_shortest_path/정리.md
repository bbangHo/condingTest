# 최단 경로

### 최소비용 구하기

---
# 힙이란?

- `최솟값` 또는 `최댓값`을 `빠르게` 찾아내기 위해 `완전이진트리` 형태로 만들어진 자료구조

    <aside>
    💡 완전 이진 트리?
    1. 마지막 레벨을 제외한 모든 노드가 채워져있어야함
    2. 모든 노드들은 왼쪽부터 채워져있어야함

    </aside>

- Q. 어떤 리스트에 값을 넣었다가 빼낼려고 할 때, 우선순위가 높은 것 부터 빼내려고 한다면 어떻게 해야할까?
  - 보통은 정렬을 떠올림
  - 쉽게 생각해서 숫자가 낮을 수록 우선순위가 높다고 가정할 때 매 번 새 원소가 들어올 때 마다 이미 리스트에 있던 원소들과 비교를 하고 정렬을 해야한다.
- **부모 노드는 항상 자식 노드보다 우선순위가 높다** 라는 것
  - 즉 최소값을 O(1)에 찾아 낼 수 있다.

![min & max heap](https://prod-files-secure.s3.us-west-2.amazonaws.com/7ff050b2-ec0f-470d-bd9d-89ac5feaca73/b3f7e98e-9b02-43a3-a8f6-c6b8052be407/Untitled.png)

- 형제간(같은 레벨간) 대소비교는 필요가 없다.
  - 우선순위가 높은 순서대로 뽑히는 게 핵심이기 때문

### 최소힙 구현

![min healp](https://prod-files-secure.s3.us-west-2.amazonaws.com/7ff050b2-ec0f-470d-bd9d-89ac5feaca73/6e73a1b5-6d38-4ebc-a34a-edbbcbc45b2a/Untitled.png)

- 힙을 배열로 구현했을 때 `특징`
  1. 구현의 용이함을 위해 시작 인덱스(root)는 1 부터 시작한다.
  2. 각 노드와 대응되는 배열의 인덱스는 '불변한다'
    - 노드 n의 자식은 항상 2n, 2n+1 번째에 위치한다. (n은 부모노드 index)

### 자바에서 힙

```java
PriorityQueue<Integer> prioQ = new PriorityQueue<>();

...

static class Node {
        int idx;
        int cost;
...
}

// 람다식 사용
PriorityQueue<Node> prioQ = new PriorityQueue<>((n1, n2) -> n1.cost - n2.cost);
```

- 이렇게 구현되어 있기 때문에 사용방법만 알면된다.
- 제네릭 타입이 객체인 경우 비교 방법을 지정해줘야한다.

---
### 문제
- 백준 1916번 https://www.acmicpc.net/problem/1916
- 개선된 다익스트라 알고리즘 정리: https://minchul-son.tistory.com/365
- 플로이드 + 다익스트라 + 개선 다익스트라 정리: https://scshim.tistory.com/389
- 코테관점: https://jeong-devlog.tistory.com/entry/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EC%9A%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-feat%EC%B5%9C%EB%8B%A8-%EA%B2%BD%EB%A1%9C
- 접근
    - 시간 제한 0.5 -> N이 최대 1,000, M 이 최대 100,000 즉, O(NM) 으로 안풀림 O(NlogM) 정도면 풀릴 듯
    - 알아보니 우선순위 큐를 사용하는 다익스트라 알고리즘이 O(VlogE)의 시간복잡도를 가진다하여 이걸 사용하면 될 듯
    - prioQ.add(next); 이 한줄 때문에 3일을 삽질했는데,, 
    - 우선순위 큐가 
