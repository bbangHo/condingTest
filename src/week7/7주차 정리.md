# 7주차 정리
## == / equals()
1. ==
- 주소의 값을 비교(Call By Reference)
  주소의 값이란 실제 내용의 값이 아닌 자료의 위치의 값이라고 생각하면 편함.
2. equals()
- equals() 메소드는 객체끼리 내용 비교(Call By value)

예제

        String str1 = "abc";
        String str2 = str1;
        String str3 = new String("abc");

        // == 연산자는 주소를 비교합니다.
        System.out.println(str1 == str2); // true
        // str2 에 st1 값을 넣었으므로 주소를 같이 공유합니다.

        System.out.println(str1 == str3); // false
        // str1 과 str3는 각각 생성 되었으므로 주소가 다릅니다.

        // equals() 는 내용을 비교합니다.
        System.out.println(str1.equals(str2)); // ture
        System.out.println(str1.equals(str3)); // true
        // 내용을 비교하기떄문에 abc 내용이 같으므로 true 가 반환됩니다.


1. str1 == str2
   -> str2를 st1에 넣었기 때문에 같은 주소를 사용하고 있어서 true

2. str1 == str3
   -> str3은 새로운 new String으로 새로운 주소를 부여해서 주소비교로 인해 false
   -> st1과 str3은 다른 객체이기 때문.

3. str1.equals(str2)
   -> true. 내용 비교이므로 abc 내용이 같아서 true

4. str1.equals(str3)
   -> true. 내용 비교이므로 abc 내용이 같아서 true

문자열을 비교할때에는 == 보다는 equals 사용 권장

## split()함수
- 형태 : String[] str1 = str.split(분할기준문자)
- 분할된 갯수만큼 index가 만들어짐

## stack
- 선언 : Stack<자료형> stack = new stack;
- 함수 : stack.push(item), stack.pop(item), stack.size(), stack.get(value), stack.isEmpty() 등

## Hashset
- 성질 : 중복 허용 x, 저장된 순서가 보장되지 않음
- 선언
// 타입을 지정 가능
  HashSet<String> animals1 = new HashSet<String>();

// 타입을 생략하여 사용 가능 -> 빈 HashSet생성 시 사용
HashSet<String> animals2 = new HashSet<>();

// 초기 용량(Capacity) 설정
HashSet<String> animals3 = new HashSet<>(10);

// animal의 모든 값을 가진 HashSet 생성
HashSet<String> animals4 = new HashSet<>(animals1);

//초기값 지정 가능
HashSet<String> animals5 = new HashSet<>(Arrays.asList("tiger", "lion", "fox")); 

- 함수 
추가 : set.add(item)
크기 : set.size()
제거 : set.remove(value), set.clear()
검색 : set.contains(value)
출력 
Iterator iter = set.iterator();
//hasNext() : 가져올 객체가 있다면 true 리턴, 없다면 false 리턴
// next() : Iterator에서 하나의 객체를 가져올 수 있는 메소드
while(iter.hasNext()) {
System.out.println(iter.next());
}





