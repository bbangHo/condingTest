# 이분탐색

![이분탐색사진](https://velog.velcdn.com/images/ming/post/ab848f15-3998-4e61-b061-01458ad6f18d/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89.png)


# hashmap

![해쉬맵](https://miro.medium.com/v2/resize:fit:720/format:webp/1*NyCDMPGGBg44Yy667nBBeA.jpeg)

## hashmap 주요 메서드
### 예시코드
         //1. put
    myMap.put("Korean", 90);
    myMap.put("Math", 80);
    myMap.put("English", 87);
    myMap.put("Science", 90);

    System.out.println(myMap.toString());   //{English=87, Science=90, Korean=90, Math=80}

    myMap.put("English", 95);

    System.out.println(myMap.toString());   //{English=95, Science=90, Korean=90, Math=80}

    //2. remove
    myMap.remove("English");

    System.out.println(myMap.toString());   //{Science=90, Korean=90, Math=80}

    //3. get
    System.out.println(myMap.get("Korean"));        //90

    //4. size
    System.out.println(myMap.size());       //3

    //5. contains
    System.out.println(myMap.containsKey("Math"));  //true
    System.out.println(myMap.containsKey("English"));   //false
    System.out.println(myMap.containsValue(90));    //true

    //6. keySet, Values
    System.out.println(myMap.keySet());             //[Science, Korean, Math]

    System.out.println(myMap.values());             //[90, 90, 80]

    //7. forEach
    for(String subject: myMap.keySet()) {
        System.out.println(subject);    //Science, ...
    }

### put
-  Map 안에 값을 넣기 위해서는 put을 사용합니다. 선언부에서 정의했던 자료형의 쌍을 집어넣게 되는데, HashSet에서처럼 작성한 코드의 순서와는 상관없이 값이 저장됩니다 (map 안에서 저장되는 위치가 랜덤).
  또한, 앞서 설명한듯이 key값은 중복이 불가능합니다. 예시 코드에서처럼 "English"라는 key에 새로운 value "95"를 넣게되면, 기존에 가지고 있던 값을 잃어버리고 새로운 값만 들어가게 됩니다.
  
### remove
- Map을 쉽게 이해하는 방법 중 하나는, key를 다른 자료구조에서의
  index로 치환하여 생각하는 것입니다. 이를테면 ArrayList에서 값을 호출하기위해서는 remove(index의 번호)를 사용하는 것처럼 Map에서는 remove(key)가 되는 것입니다. 
  remove의 결과로 해당 key와 value가 모두 지워지게 됩니다.

### get
- remove와 마찬가지로 get메서드 역시 index대신 key를 사용하여 value를 호출하게 됩니다. 어차피 하나의 Map에는 중복되는 key가 존재하지 않으므로, 고유한 key는 하나의 value만을 가지게 됩니다. 그럼 value를 사용하여 key를 호출할 수는 없을까요? Map에서는 key에 대한 중복을 허락하지 않지만, value는 같은 값을 가져도 상관없습니다. 따라서 역으로 key값을 반환하는 메서드는 존재하지 않습니다.

### size
- size메서드는 Map의 크기를 int Type으로 반환하는 메서드입니다.

### contains
- 차이점이 있다면, Map의 key와 value에 각각 따로 containsKey와 containsValue라는 메서드가 구현되어 있다는 점입니다. 상황에 맞게 사
  용하실 수 있습니다.

### KeySet, Values
- keySet은 Map이 가지고 있는 key를, Values는 Map이 가지고있는 value를 각각 반환합니다.

# 투 포인터

![투포인터](https://velog.velcdn.com/images%2Fsong_lego%2Fpost%2F5cdc2189-2c7a-4c96-86a8-11e978daeb79%2FScreen%20Shot%202021-10-01%20at%201.45.34%20PM.png)

1. 시작점(start)과 끝점(end)이 첫 번째 원소의 인덱스(0)를 가리키도록 한다.
2. 현재 부분 합이 M과 같다면, 카운트한다.
3. 현재 부분 합이 M보다 작다면, end를 1 증가시킨다.
4. 현재 부분 합이 M보다 크거나 같다면, start를 1 증가시킨다.
5. 모든 경우를 확인할 때 까지 2~4 과정을 반복한다.


# LIS

📌 최장 증가 부분 수열(LIS, Longest Increasing Subsequence)란?

원소가 n개인 배열의 일부 원소를 골라내서 만든 부분 수열 중, 각 원소가 이전 원소보다 크다는 조건을 만족하고, 그 길이가 최대인 부분 수열을 최장 증가 부분 수열이라고 합니다.

예를 들어, { 6, 2, 5, 1, 7, 4, 8, 3} 이라는 배열이 있을 경우, LIS는 { 2, 5, 7, 8 } 이 됩니다.
{ 2, 5 }, { 2, 7 } 등 증가하는 부분 수열은 많지만 그 중에서 가장 긴 것이 { 2, 5, 7, 8 } 입니다.


## 이분탐색을 이용한 LIS

시간복잡도를 개선하기 위하여 LIS를 구성할 때 이분탐색을 활용합니다.

즉, LIS의 형태를 유지하기 위해 주어진 배열의 인덱스를 하나씩 살펴보면서 그 숫자가 들어갈 위치를 이분탐색으로 탐색해서 넣습니다.

이분탐색은 일반적으로 시간복잡도가 O(log n) 이라고 알려져 있으므로, 이 문제의 시간 복잡도를 O(nlog n)으로 개선시킬 수 있게 됩니다.

![LIS](https://velog.velcdn.com/images%2Fseho100%2Fpost%2Fce83ccec-524d-4a82-a481-650069328237%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-07-26%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%202.52.12.png)

- 하지만 나는 LIS[0] 에 -무한대 값을 초기값으로 넣어두고, arr[0]부터 비교해 나가며 알고리즘을 작성했다. 이유 -> 그게 더 간단한거 같아서
