# 백준 11478(서로 다른 부분 문자열의 개수)

- 이 문제는 처음에 풀 때 hashmap의 containvalue를 이용해서 
같은 value 값이 없으면 map에 추가해나가는 방식으로 풀려고했다
그런데 시간복잡도 문제인지 시간 초과가 계속 떠서 이 방법은 안되겠구나, 생각이 들어서
다른 방법을 생각해보던 중, hashset이 생각 났고 hashset은 값을 추가 할 때
이미 같은 값이 있는지 확인하고 추가한다는 특성이 생각났다. 그래서 찾아본 결과 hashset은 
내부적으로 hashmap의 containkey를 사용한다는 사실을 알게 되었고, 이 자료구조를 사용해 시간
복잡도를 줄일 수 있었고, 문제를 해결할 수 있었다.
-> collection 같은 라이브러리들을 많이 알면 알 수록 좋은것 같았다.

# 프로그래머스258712

- 카카오 문제라서 살짝 쫄았었는데 그냥 생각한대로 풀어보니 풀렸음 1렙이라 그런듯하다.

# 프로그래머스181188

- 끝점을 기준으로 정렬시키고 기준점 x를 0으로 초기화 하고
미사일 시작점과 기준점을 비교해가며 만약 기준점이 시작점보다 작거나 같으면 기준점을
미사일 끝점으로 갱신하고 요격기를 하나추가해 나가며 요격기의 최솟값을 구함

# 백준9935

- 맨 처음에 그냥 폭발하는 문자열의 문자가 포함만 되면 터트리는 문제인줄 알고 풀었다가
폭발하는 문자열과 동일하게 주어진 문자열 안에 있으면 그부분을 없애고 공백을 이어 붙이는 식으로
해결 해야 한다는 것을 알게 되어 다시 풀었다.
그런데 나는 출력을 그냥 List 반복문 돌리면서 출력하니깐 시간 초과뜨길래 뭐지 하고 찾아보니
List를 반복문으로 처음부터 끝까지 돌리며 출력하면 하나 출력하고 List 크기 조정하고 반복해서 시간복잡도가 
엄청 커진다 그러는 것 같아서 StringBuilder 사용해서 풀었다.

# 백준9024

- 문제를 해결하기는 했는데 코드가 좀 더러워 보이고 아쉬워서 수정하다가 ABS의 초기값을 Integer.MAX_VALUE
로 했는데 60퍼에서 계속 틀렸다. 그런데 로직상에는 문제가 없게 수정 했어서 ABS의 초기값이 문제인가 싶어서 Integer.MAX_VALUE말고
abs(K-(배열 처음, 끝의합))으로 해봤더니 잘 됐다. 결론은 그냥
  if(Math.abs(K - sum) <= ABS) 이 조건문에서 Math.abs(K - sum) 값이 Integer.MAX_VALUE의 값을 초과해버려서 그런듯했다
            